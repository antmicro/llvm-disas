#
# Copyright (c) 2019-2024 Antmicro
#
# This file is licensed under the Apache License 2.0.
# Full license text is available in the 'LICENSE' file.

# Because of `BUILD_RPATH_USE_ORIGIN` target property
cmake_minimum_required(VERSION 3.14)

project (renode-llvm-disas)


# Variables describing LLVM libraries

set(LLVM_SRC_URL    https://github.com/llvm/llvm-project/archive/llvmorg-20.1.2.tar.gz)
set(LLVM_SRC_SHA512 0550571718623a16d85b58222bc61bd6a47ab7a8d9183e58d3b66f33424ed0bfa45c75687312b43515a00815e955f64328db214f4ea4656dcfd652cea949467e)

# Some LLVM headers are generated by CMake and arch-specific.
set(LLVM_INCL_DIR   ${CMAKE_SOURCE_DIR}/cache/${CMAKE_SYSTEM_PROCESSOR}/include)
set(LLVM_LIBS_DIR   ${CMAKE_SOURCE_DIR}/cache/${CMAKE_SYSTEM_PROCESSOR}/lib)
set(LLVM_LIBS       AArch64Desc AArch64Disassembler AArch64Info AArch64Utils ARMDesc ARMDisassembler ARMInfo ARMUtils BinaryFormat TargetParser Object Demangle MC MCDisassembler MipsDesc MipsDisassembler MipsInfo PowerPCDesc PowerPCDisassembler PowerPCInfo RISCVDesc RISCVDisassembler RISCVInfo SparcDesc SparcDisassembler SparcInfo Support X86Desc X86Disassembler X86Info
    AArch64AsmParser ARMAsmParser MCParser MipsAsmParser PowerPCAsmParser RISCVAsmParser SparcAsmParser X86AsmParser) # The libraries on this line are required for assembling

# On macOS "sys::PrintStackTrace" needs extra "itaniumDemangle" function from LLVMDemangle library
if(CMAKE_HOST_APPLE)
    list(APPEND LLVM_LIBS Demangle)
endif()

foreach(LIB ${LLVM_LIBS})
    list(APPEND LLVM_LIB_PATHS ${LLVM_LIBS_DIR}/libLLVM${LIB}.a)
endforeach(LIB)

set(BUILD_LLVM_LIBS OFF CACHE BOOL "Controls whether LLVM will be built from source; by default '${LLVM_LIBS_DIR}/libLLVM*.a' are used if all required libraries are found.")
if(NOT BUILD_LLVM_LIBS)
    # Make sure the directory contains all the required LLVM libraries; otherwise build them all.
    foreach(LIB ${LLVM_LIB_PATHS})
        if(NOT EXISTS ${LIB})
            message(WARNING "A required '${LIB}' library wasn't found! All LLVM libraries will be rebuilt.")
            set(BUILD_LLVM_LIBS ON)
            break()
        endif()
    endforeach()

    # This one is configured by CMake so others should also be present if it exists.
    set(LLVM_CONFIG_HEADER ${LLVM_INCL_DIR}/llvm/Config/llvm-config.h)
    if(NOT EXISTS ${LLVM_CONFIG_HEADER})
        message(WARNING "A required '${LLVM_CONFIG_HEADER} header wasn't found! The LLVM will be rebuilt to properly cache all the headers.")
        set(BUILD_LLVM_LIBS ON)
    endif()
endif()


# Define targets

add_definitions(-Werror)
add_definitions(-Wall)

set(LLVM_TABLEGEN "" CACHE STRING "Path to prebuilt llvm-tblgen binary to use, needed when cross-compiling")
set(LLVM_TABLEGEN_COPY_COMMAND "")

if(NOT CMAKE_HOST_WIN32)
    set(STATIC_LLVM_DISAS OFF CACHE BOOL "Controls whether llvm-disas will be a static library; by default it's a shared library")
    if(NOT CMAKE_CROSSCOMPILING)
        set(LLVM_TABLEGEN_COPY_COMMAND ${CMAKE_COMMAND} -E copy_if_different ${CMAKE_BINARY_DIR}/llvm-ep-prefix/src/llvm-ep-build/bin/llvm-tblgen ${CMAKE_BINARY_DIR})
    endif()
endif()

if(STATIC_LLVM_DISAS)
    # LLVM objects' paths are specified after extracting them from the LLVM libraries
    add_library(llvm_objs OBJECT IMPORTED)
    add_library(llvm-disas STATIC init.c stub.c create_disasm.c disasm_instruction.c assemble.cc dispose.c $<TARGET_OBJECTS:llvm_objs>)

    set(TARGET_LINKING_LLVM_LIBS test-app)
else()
    add_library(llvm-disas SHARED init.c stub.c create_disasm.c disasm_instruction.c assemble.cc dispose.c)
    target_link_libraries(llvm-disas PRIVATE
        $<$<CXX_COMPILER_ID:GNU>:-Wl,--unresolved-symbols=report-all>
        $<$<CXX_COMPILER_ID:GNU>:-static-libgcc>
        $<$<CXX_COMPILER_ID:GNU>:-static-libstdc++>
        # In case it isn't passed to the linker by default (e.g. g++ v8.3.0-6 on Debian 10)
        $<$<CXX_COMPILER_ID:GNU>:-Wl,--as-needed>
    )

    # PRIVATE to make sure llvm-disas contains everything. With the default PUBLIC, LLVM libraries are propagated to the test-app linkage.
    target_link_libraries(llvm-disas PRIVATE
        # LLVM libraries have some dependencies between themselves
        # GNU linker requires grouping such libraries to search them again as long as new symbols emerge and remain unresolved
        $<$<CXX_COMPILER_ID:GNU>:-Wl,--start-group>
        ${LLVM_LIB_PATHS}
        $<$<CXX_COMPILER_ID:GNU>:-Wl,--end-group>
        # Make sure MinGW links all non-Windows libraries statically
        # ntdll required for RtlGetLastNtStatus in llvm/lib/Support/ErrorHandling.cpp.
        # Quotes: see https://cmake.org/pipermail/cmake/2018-October/068344.html. The normal way works on CMake 3.25
        "$<$<BOOL:${CMAKE_HOST_WIN32}>:ntdll;-static>"
    )

    # Suppress CMP0042 policy warning about not setting MACOSX_RPATH for library on MAC OS X (which is only used in 'make install')
    if(CMAKE_HOST_APPLE)
        set_property(TARGET llvm-disas PROPERTY MACOSX_RPATH OFF)
    endif()

    set(TARGET_LINKING_LLVM_LIBS llvm-disas)
endif()

target_compile_features(llvm-disas PRIVATE cxx_std_17)
set_source_files_properties(assemble.cc PROPERTIES COMPILE_OPTIONS "-fno-rtti")

add_executable(test-app test.c)
target_link_libraries(test-app PRIVATE llvm-disas)
# Search libraries in a runtime directory (ELFs `RPATH` is set to '$ORIGIN')
set_target_properties(test-app PROPERTIES BUILD_RPATH_USE_ORIGIN TRUE)
set_target_properties(test-app PROPERTIES LANGUAGES C)

# Use "C++ linker" to link target as LLVM code is written in C++
set_property(TARGET ${TARGET_LINKING_LLVM_LIBS} PROPERTY LINKER_LANGUAGE "CXX")

# LLVM libraries use POSIX threads and libdl
target_link_libraries(${TARGET_LINKING_LLVM_LIBS} PRIVATE pthread dl)

# During the LLVM libraries' building also the headers are cached.
# The 'llvm/Config' ones are generated by CMake.
target_include_directories(llvm-disas PRIVATE ${LLVM_INCL_DIR})

# Link OpenLibm on Linux instead of libm required by LLVM code
if(${CMAKE_HOST_SYSTEM_NAME} STREQUAL Linux)
    target_link_libraries(${TARGET_LINKING_LLVM_LIBS} PRIVATE ${CMAKE_SOURCE_DIR}/lib/openlibm/libopenlibm-Linux-${CMAKE_SYSTEM_PROCESSOR}.a)
endif()


# Build LLVM libraries

if(BUILD_LLVM_LIBS)
    # It doesn't fail if the directory exists.
    file(MAKE_DIRECTORY ${LLVM_LIBS_DIR})

    foreach(LIB ${LLVM_LIBS})
        list(APPEND LLVM_MAKE_TARGETS LLVM${LIB})
        list(APPEND LLVM_BUILD_PATHS  ${CMAKE_BINARY_DIR}/llvm-ep-prefix/src/llvm-ep-build/lib/libLLVM${LIB}.a)
    endforeach(LIB)

    if(LLVM_TABLEGEN)
        set(LLVM_TABLEGEN_OPTION "-DLLVM_TABLEGEN=${LLVM_TABLEGEN}")
    else()
        set(LLVM_TABLEGEN_OPTION "")
    endif()

    if("${LLVM_SRC_URL}" MATCHES "releases.*llvm-[0-9]")
        # The 'llvm-$VERSION' source archives published with a release have 'llvm' contents only.
        set(LLVM_SRC_SUBDIR  .)
        set(LLVM_PATCH_LEVEL 2)
    else()
        # GH repository archives for 'llvm-project' contain clang, llvm etc. directories.
        set(LLVM_SRC_SUBDIR  llvm)
        set(LLVM_PATCH_LEVEL 1)
    endif()

    include(ExternalProject)
    ExternalProject_Add(llvm-ep
        DOWNLOAD_DIR    ${CMAKE_SOURCE_DIR}/cache
        URL             ${LLVM_SRC_URL}
        URL_HASH        SHA512=${LLVM_SRC_SHA512}
        SOURCE_SUBDIR   ${LLVM_SRC_SUBDIR}
        PATCH_COMMAND   sh -c "find ${CMAKE_CURRENT_LIST_DIR}/llvm-patches -name '*.patch' | sort -n | while read -r p $<SEMICOLON> do patch -p${LLVM_PATCH_LEVEL} < \"$p\" $<SEMICOLON> done"
        CMAKE_ARGS      "-DLLVM_ENABLE_ZSTD=OFF" "-DLLVM_ENABLE_ZLIB=OFF" "-DLLVM_FORCE_VC_REPOSITORY='git@github.com:antmicro/llvm-disas.git'" "-DCMAKE_SH=${CMAKE_SH}" "-DCMAKE_BUILD_TYPE=${CMAKE_BUILD_TYPE}" "-DCMAKE_TOOLCHAIN_FILE:FILEPATH=${CMAKE_TOOLCHAIN_FILE}" "${LLVM_TABLEGEN_OPTION}"
        # The jobserver environment for parallel building is only passed properly if '$(MAKE)' is used.
        BUILD_COMMAND   "$(MAKE)" ${LLVM_MAKE_TARGETS}
        COMMAND         ${CMAKE_COMMAND} -E copy_if_different ${LLVM_BUILD_PATHS} ${LLVM_LIBS_DIR}
        COMMAND         ${LLVM_TABLEGEN_COPY_COMMAND}
        COMMAND         ${CMAKE_COMMAND} -E copy_directory "${CMAKE_BINARY_DIR}/llvm-ep-prefix/src/llvm-ep/llvm/include" ${LLVM_INCL_DIR}
        # Some headers are generated by CMake in the External Project's '-build' directory.
        COMMAND         ${CMAKE_COMMAND} -E copy_directory "${CMAKE_BINARY_DIR}/llvm-ep-prefix/src/llvm-ep-build/include" ${LLVM_INCL_DIR}
        INSTALL_COMMAND ""
        TEST_COMMAND    ""
    )

    add_dependencies(llvm-disas llvm-ep)
endif()


# Extract LLVM objects to combine into a single static library

if(STATIC_LLVM_DISAS)
    set(LLVM_OBJS_DIR ${CMAKE_BINARY_DIR}/obj)

    foreach(LIB ${LLVM_LIBS})
        file(MAKE_DIRECTORY ${LLVM_OBJS_DIR}/${LIB})
        execute_process(COMMAND ${CMAKE_AR} -x ${LLVM_LIBS_DIR}/libLLVM${LIB}.a WORKING_DIRECTORY ${LLVM_OBJS_DIR}/${LIB})
    endforeach(LIB)

    file(GLOB_RECURSE LLVM_OBJS ${LLVM_OBJS_DIR}/*.o)
    set_target_properties(llvm_objs PROPERTIES IMPORTED_OBJECTS "${LLVM_OBJS}")
endif()


# CTEST

enable_testing()

add_test(NAME info COMMAND test-app)
set_tests_properties(info PROPERTIES PASS_REGULAR_EXPRESSION "^Usage:")

# Optional argument: extra flags to pass to test-app
function(disassemble triple cpu code result)
    set(TEST_NAME disassemble_${triple}_${cpu}_${code}_${ARGV4})
    add_test(NAME ${TEST_NAME} COMMAND test-app ${ARGV4} ${triple} ${cpu} ${code})

    # Escapes special regex characters expected in the result
    string(REGEX REPLACE "\\$" "\\\\$" RES_ESC ${result})
    string(REGEX REPLACE "\\(" "\\\\(" RES_ESC ${RES_ESC})
    string(REGEX REPLACE "\\)" "\\\\)" RES_ESC ${RES_ESC})
    string(REGEX REPLACE "\\[" "\\\\[" RES_ESC ${RES_ESC})
    string(REGEX REPLACE "\\]" "\\\\]" RES_ESC ${RES_ESC})
    string(REGEX REPLACE "\\." "\\\\." RES_ESC ${RES_ESC})
    string(REGEX REPLACE "\\+" "\\\\+" RES_ESC ${RES_ESC})

    # Allows different whitespace characters in place of SPACEs.
    # Typically TABs are returned but Sparc and PPC sometimes return SPACEs.
    #
    # Also allows specifying multiline results in a single line.
    string(REGEX REPLACE " +" "[\ \t\n]*" RES_ESC ${RES_ESC})

    set_tests_properties(${TEST_NAME} PROPERTIES PASS_REGULAR_EXPRESSION "^\t${RES_ESC}\n$")
endfunction(disassemble)

# Optional argument: extra flags to pass to test-app
function(assemble triple cpu result code)
    string(REGEX REPLACE "[^a-zA-Z0-9]+" "_" code_nospecials ${code})
    set(TEST_NAME assemble_${triple}_${cpu}_${code_nospecials})

    add_test(NAME ${TEST_NAME} COMMAND test-app -a ${ARGV4} ${triple} ${cpu} ${code})

    # Ignore spaces between hex bytes in output
    string(REGEX REPLACE "(..)" "\\1\ ?" result ${result})

    set_tests_properties(${TEST_NAME} PROPERTIES PASS_REGULAR_EXPRESSION "${result}")
endfunction(assemble)

# Optional argument: extra flags to pass to test-app
function(bothways triple cpu result code)
    assemble(${triple} ${cpu} ${result} ${code} ${ARGV4})
    disassemble(${triple} ${cpu} ${result} ${code} ${ARGV4})
endfunction(bothways)

set(ARCH riscv32 generic-rv32) # rv32i
bothways   (${ARCH} 9304020023002310  "mv     s1, tp\n          sb      sp, 256(t1)"    )
bothways   (${ARCH} 3384844093040200  "sub    s0, s1, s0\n      mv      s1, tp"         )
# The partial instruction (3 bytes) will be ignored
disassemble(${ARCH} 33848440930402    "sub    s0, s1, s0"             )
bothways   (${ARCH} 33848440          "sub    s0, s1, s0"             )
bothways   (${ARCH} 23282101          "sw     s2, 16(sp)"             )
bothways   (${ARCH} b385b700          "add    a1, a5, a1"             )
bothways   (${ARCH} 97820000          "auipc  t0, 8"                  )
# Zifencei and Zicsr extensions don't need to be enabled
bothways   (${ARCH} 0f100000          "fence.i        "               ) # Zifencei
bothways   (${ARCH} 73f10134          "csrrci sp, mscratch, 3"        ) # Zicsr

set(ARCH riscv32 rv32i_zacas) # With Zacas extension
bothways   (${ARCH} 2f26b528          "amocas.w a2, a1, (a0)"         ) # Zacas

set(ARCH riscv32 rv32imafdc) # The same as rv32gc
bothways   (${ARCH} 335cab02          "divu           s8, s6, a0"     ) # rv32m
bothways   (${ARCH} 2f250508          "amoswap.w      a0, zero, (a0)" ) # rv32a
bothways   (${ARCH} d3230158          "fsqrt.s        ft7, ft2, rdn"  ) # rv32f
bothways   (${ARCH} d323015a          "fsqrt.d        ft7, ft2, rdn"  ) # rv32d
bothways   (${ARCH} bcea              "fsw            fa5, 80(a3)"    ) # rv32c

set(ARCH riscv32 rv32gc) # The same as rv32imafdc
bothways   (${ARCH} 335cab02          "divu           s8, s6, a0"     ) # rv32m
bothways   (${ARCH} 2f250508          "amoswap.w      a0, zero, (a0)" ) # rv32a
bothways   (${ARCH} d3230158          "fsqrt.s        ft7, ft2, rdn"  ) # rv32f
bothways   (${ARCH} d323015a          "fsqrt.d        ft7, ft2, rdn"  ) # rv32d
bothways   (${ARCH} bcea              "fsw            fa5, 80(a3)"    ) # rv32c

set(ARCH riscv32 rv32iv)
bothways   (${ARCH} 57301276          "vmsle.vi       v0, v1, 4"      )
bothways   (${ARCH} 5770360c          "vsetvli        zero, a2, e8, m8, ta, ma" )
bothways   (${ARCH} 07840503          "vle8ff.v       v8, (a1)"       )
bothways   (${ARCH} d7308062          "vmseq.vi       v1, v8, 0"      )
bothways   (${ARCH} 57a71842          "vfirst.m       a4, v1"         )
bothways   (${ARCH} 57a01052          "vmsbf.m        v0, v1"         )

set(ARCH riscv64 generic-rv64) # rv64i
bothways   (${ARCH} 833a0a00          "ld     s5, 0(s4)"              )
bothways   (${ARCH} 9b8acdab          "addiw  s5, s11, -1348"         )

set(ARCH riscv64 rv64imafdc) # The same as rv64gc
bothways   (${ARCH} 3b7cab02          "remuw          s8, s6, a0"     ) # rv64m
bothways   (${ARCH} 2fb505e7          "amomaxu.d.aqrl a0, a6, (a1)"   ) # rv64a
bothways   (${ARCH} 532331d0          "fcvt.s.lu      ft6, sp, rdn"   ) # rv64f
bothways   (${ARCH} 532331d2          "fcvt.d.lu      ft6, sp, rdn"   ) # rv64d
bothways   (${ARCH} bcea              "sd             a5, 80(a3)"     ) # rv64c

set(ARCH riscv64 rv64gc) # The same as rv64imafdc
bothways   (${ARCH} 3b7cab02          "remuw          s8, s6, a0"     ) # rv64m
bothways   (${ARCH} 2fb505e7          "amomaxu.d.aqrl a0, a6, (a1)"   ) # rv64a
bothways   (${ARCH} 532331d0          "fcvt.s.lu      ft6, sp, rdn"   ) # rv64f
bothways   (${ARCH} 532331d2          "fcvt.d.lu      ft6, sp, rdn"   ) # rv64d
bothways   (${ARCH} bcea              "sd             a5, 80(a3)"     ) # rv64c

set(ARCH riscv64 rv64iv)
bothways   (${ARCH} 57301276          "vmsle.vi       v0, v1, 4"      )
bothways   (${ARCH} 5770360c          "vsetvli        zero, a2, e8, m8, ta, ma" )
bothways   (${ARCH} 07840503          "vle8ff.v       v8, (a1)"       )
bothways   (${ARCH} d7308062          "vmseq.vi       v1, v8, 0"      )
bothways   (${ARCH} 57a71842          "vfirst.m       a4, v1"         )
bothways   (${ARCH} 57a01052          "vmsbf.m        v0, v1"         )

set(ARCH thumb cortex-m4)
bothways   (${ARCH} d1430b4423f00304  "mvns   r1, r2\n  add     r3, r1\n  bic     r4, r3, #3" )
bothways   (${ARCH} c2f20002          "movt   r2, #8192"              )
bothways   (${ARCH} c858              "ldr    r0, [r1, r3]"           )
bothways   (${ARCH} 4ff46d42          "mov.w  r2, #60672"             )
bothways   (${ARCH} b610              "asrs   r6, r6, #2"             )

set(ARCH arm arm926ej-s)
bothways   (${ARCH} 01508532          "addlo  r5, r5, #1"             )
bothways   (${ARCH} 000ab0e1          "lsls   r0, r0, #20"            )
bothways   (${ARCH} 0a00001a          "bne    #40"                    )

set(ARCH i386 i386)
bothways   (${ARCH} 6b7b0c14          "imull  $20, 12(%ebx), %edi"    )
bothways   (${ARCH} 45                "incl   %ebp"                   )
bothways   (${ARCH} 0fb7c0            "movzwl %ax, %eax"              )
bothways   (${ARCH} 66890cc516a9fd00  "movw   %cx, 16623894(,%eax,8)" )
bothways   (${ARCH} 0f011d5e00fc00    "lidtl  16515166"               )
assemble   (${ARCH} e3fe8d0500000000  "a: jecxz a\n leal a, %eax"     )
assemble   (${ARCH} 7afe8d0502000000  "a: jp a\n b: leal b-a, %eax"   )
# Alternate dialect (Intel syntax)
bothways   (${ARCH} 0fb7c0            "movzx eax, ax"             "-d")
bothways   (${ARCH} 8b0424            "mov eax, dword ptr [esp]"  "-d")
assemble   (${ARCH} 66890cc516a9fd00  "mov [16623894+eax*8], cx"  "-d")
assemble   (${ARCH} e3fe8d0500000000  "a: jecxz a\n lea eax, [a]" "-d")
# With nonzero base address
assemble   (${ARCH} 8d0534120000      "a: lea eax, [a]" "-d;-b 0x1234")
assemble   (${ARCH} 66408d0536120000  "inc ax\n a: lea eax, [a]" "-d;-b 0x1234")

set(ARCH sparc leon3)
bothways   (${ARCH} 85e8a018          "restore        %g2, 24, %g2"   )
bothways   (${ARCH} 01000000          "nop"                           )
bothways   (${ARCH} 10680047          "ba     %xcc, 71"               )
bothways   (${ARCH} 81d80000          "flush %g0"                     )
bothways   (${ARCH} 81d82000          "flush 0"                       )
bothways   (${ARCH} 81d84000          "flush %g1"                     )
bothways   (${ARCH} 81d86020          "flush %g1+32"                  )
bothways   (${ARCH} 81d8401c          "flush %g1+%i4"                 )

set(ARCH ppc ppc32)
bothways   (${ARCH} 4800007c          "b      .+124"                  )
bothways   (${ARCH} 7f880040          "cmplw  7, 8, 0"                )
bothways   (${ARCH} 7ce40034          "cntlzw 4, 7"                   )

# Invalid instruction
assemble   (${ARCH} "invalid ins"     "notarealppcinstruction"        )

# Undefined label
assemble   (${ARCH} "Undefined label x"     "b      x"                )

# Invalid target
set(ARCH ppc notarealppccpu)
assemble   (${ARCH} "Invalid CPU"     "nop"                           )
set(ARCH notarealarch notarealppccpu)
assemble   (${ARCH} "Unknown target"  "nop"                           )
